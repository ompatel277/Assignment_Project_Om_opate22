A career exploration app where different career roles are mapped out with college classes
and different clubs that the user can explore to gain insights on which classes are the best
to take and which clubs will best help you reach your goal. It provides AI-driven
recommendations, college-specific next steps, and clear explanations of career roles and required skills.

I used the python environment because I like it better than setting up the conda one.

I chose Traject because while you are using this app it is going to map out the trajectory of different career roles

HW 2: As for the branching strategy I will use the github strategy because I am the only one working on the project. I will create a test branch to test the features of the app and then push it to main branch.

HW 3
Why these models/fields?
I chose these models because I can get an idea of what the app would look like when the user first sign-up and logs in. I think it will help me add or eliminate possible features.

Your relationship choices (ForeignKey, on_delete rationale),
ForeignKey, unique, and primary key. I am still playing around with these optoins not set and stone yet but will figure out more as I continue the project

Any constraints (unique, ordering),
I did make a unique and ordering but I got that from chatGPT and I do not know what it does fully. I was just experimenting on how things would look. But once again I will figure it out with trial and error throughout the project

How you seeded test data.
I manually added the data from the admin dashboard. I do want to try to do the dummydata once I have everything connected.


why you wrote two views,
to practice what I learned in class

whatâ€™s different between HttpResponse and render,
The difference is that http requires you to load and render a template, unlike rendor which combines all the steps into one funtion

any URL/template decisions you made.
No I used the one we saw in class for now


HW 5
For base view I had to explicitly write the get() method and pass the context to the template,
while the list view was a lot simple because I only had to add a specific  model and the template
Generic views do save a lot of time and save on using repetitive code because it automatically handles the query set.

HW 6
Filtering: the list view reads the q and narrows down the request and only returns the strings that match that row.
Aggregation: returns a single summary example is total counts of colleges in a specific state.

HW 7
Static files work in django by adding css styling and customizing it. Implemented colleges_charts which shows majors per college
As of right now the chart is not that useful but once I add more to the web-app it should become useful. I used total_colleges().
BytesIO is memory stream whihc captures the matplotlib before it renders it to http
